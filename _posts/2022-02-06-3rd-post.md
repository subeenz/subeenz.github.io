---
layout: single
title:  "[밑바닥부터 시작하는 딥러닝] Chap.2 퍼셉트론"
excerpt: "자연어처리 공부"

categories:
  - Python, NLP
tags:
  - [Blog, jekyll, Github, Git]

sidebar:
  nav: "docs"

toc: true
toc_label: "목록"
toc_icon: "bars"
toc_sticky: true
 
date: 2022-02-06
last_modified_at: 2022-02-06
---

이번 장에서는 퍼셉트론 알고리즘을 설명합니다.

### **퍼셉트론**
***

퍼셉트론 : 다수의 신호를 입력으로 받아 하나의 신호를 출력.  
이 책에서의 신호란 `1 : 신호가 흐른다. 0: 신호가 흐르지 않는다`로 사용   

다음 그림은 입력이 2개인 퍼셉트론을 나타냅니다.  

<img src="/assets/images/two_inputs_perceptron.png" width="30%" height="30%" title="그림 2-1" alt="입력이 2개인 퍼셉트론"/>  

[그림 2-1] 입력이 2개인 퍼셉트론

위 그림에서 원은 **뉴런** 혹은 **노드** 라고 부르며, $$x_{1}, x_{2} : 입력신호$$ $$y : 출력 신호$$ $$w_{1}, w_{2} : 가중치$$  
를 의미합니다.
입력 신호가 뉴런에 보내질 때는 각각 **고유한 가중치**($w$)가 곱해집니다. __`가중치가 클수록 해당 신호가 그만큼 더 중요함을 의미합니다.`__

이를 수식으로 나타내면 다음과 같습니다.  
<img src="/assets/images/퍼셉트론수식1.png" width="20%" height="20%" title="식 2-1" alt="퍼셉트론 동작 원리 수식"/>  
[식 2-1]

위 수식은 뉴런에서 보내온 신호의 총합이 정해진 한계를 넘어설 때, 즉 **임계값($\theta$) 이상**일 경우에만 1을 출력함을 의미합니다. 이때 1을 출력할 경우 '뉴런이 활성화한다'라고 표현하기도 합니다.

### **퍼셉트론을 활용한 단순한 논리회로 구현**
***

우리가 구현해 볼 논리 회로는 AND, NAND, OR 게이트 입니다. 이 게이트들 모두 입력이 2개, 출력이 1개입니다. 각 입력신호와 출력신호의 대응표인 **진리표**는 아래와 같습니다.

**AND Gate**
|$x_{1}$|$x_{2}$|$y$|
|:---:|:---:|:---:|
|0|0|0|
|0|1|0|
|1|0|0|
|1|1|1|

**NAND Gate**
|$x_{1}$|$x_{2}$|$y$|
|:---:|:---:|:---:|
|0|0|1|
|0|1|1|
|1|0|1|
|1|1|0|

**OR Gate**
|$x_{1}$|$x_{2}$|$y$|
|:---:|:---:|:---:|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|1|

위 게이트들을 각각 퍼셉트론으로 표현하려면 진리표대로 작동할 수 있도록 $w_{1}, w_{2}, \theta$ 의 값을 조절해야 합니다. 이를 만족하는 조합은 매우 많기 때문에 **AND 게이트**의 한 예시만 들어보겠습니다.
> $$(w_{1}, w_{2}, \theta) = (0.5,0.5,0.6)$$  
> $$(x_{1}, x_{2}) = (1,1)$$
> $$y = x_{1}w_{1}+x_{2}w_{2}$$
> $$ = 1*0.5+ 1*0.5 = 1 \geq \theta(0.6)$$ 
> $$임계값 이상 - 뉴런 활성화$$

> $$(x_{1}, x_{2}) = (0,1)$$
> $$y = x_{1}w_{1}+x_{2}w_{2}$$
> $$ = 0*0.5+ 1*0.5 = 0.5 \leq \theta(0.6)$$ 
> $$임계값 이하 - 뉴런 활성화X$$  


이를 파이썬으로 구현해보면 다음과 같습니다. 각 게이트들의 매개변수는 무수히 많기 때문에 임의로 지정한 뒤 구현했습니다.
```python
class LogicGate:

    def and_gate(self, x_1, x_2):
        w_1, w_2, theta = 0.5, 0.5, 0.7

        y = x_1 * w_1 + x_2 * w_2

        if y > theta:
            print(f"({x_1},{x_2}) AND GATE : 1")
        else:
            print(f"({x_1},{x_2}) AND GATE : 0")

    def or_gate(self, x_1, x_2):
        w_1, w_2, theta = 0.5, 0.5, 0.4

        y = x_1 * w_1 + x_2 * w_2

        if y > theta:
            print(f"({x_1},{x_2}) OR GATE : 1")
        else:
            print(f"({x_1},{x_2}) OR GATE : 0")

    def nand_gate(self, x_1, x_2):
        w_1, w_2, theta = 0.5, 0.5, 0.7

        y = x_1 * w_1 + x_2 * w_2

        # AND Gate의 반대
        if y > theta:
            print(f"({x_1},{x_2}) NAND GATE : 0")
        else:
            print(f"({x_1},{x_2}) NAND GATE : 1")


if __name__ == "__main__":
    logic_gate = LogicGate()
    logic_gate.and_gate(0, 1)
    logic_gate.or_gate(0, 1)
    logic_gate.nand_gate(0, 1)

# 결과
(0,1) AND GATE : 0
(0,1) OR GATE : 1
(0,1) NAND GATE : 1
```

위 세가지 게이트에서 다른 것은 `매개변수(가중치와 임계값)` 뿐입니다. 따라서 매개변수의 값을 적절히 조절함에 따라 다른 게이트가 될 수 있다는 것입니다.  

따라서 우리는 이 작업을 컴퓨터가 자동으로 할 수 있도록, 컴퓨터에게 **학습(적절한 매개변수 값을 정하는 작업)** 을 시킵니다.  

### **가중치와 편향**
***
앞서 직관적으로 알기 쉽게 구현했다면, 이번에는 **편향**의 개념을 도입해 구현해보겠습니다.

식2-1에서 $\theta$를 $-b$로 치환하면 퍼셉트론의 동작을 나타내는 수식은 다음 2-2와 같이 수정됩니다. 2-1, 2-2의 두 식은 기호 표기의 차이일 뿐, 의미는 동일합니다. 이때 **$b$를 편향(bias)** 이라고 합니다.

<img src="/assets/images/퍼셉트론수식2.png" width="20%" height="20%" title="식 2-2" alt="퍼셉트론 동작 원리 수식"/>  

[식 2-2]

편향이라는 용어는 '한쪽으로 치우쳐 균형을 깬다'라는 의미를 담고 있습니다. 위 식에서 입력이 모두 0이어도 그 결과값은 0이아닌 편향 값을 출력하게 됩니다.

